"""위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다.

삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.

제한사항
삼각형의 높이는 1 이상 500 이하입니다.
삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다.
입출력 예
triangle	result
[[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]	30"""



# 리프 노드의 부모 노드에서는 어떤 노드를 선택해야 큰 값을 선택하는지 알 수 있음

# 루트 노드의 depth가 0이라고 기준을 잡으면
# 트리의 깊이는 4이고, 리프 노드의 부모 노드는 깊이 3에 위치

# depth : 3일때
# 4와 5의 부모 노드인 2의 입장에서는 5 유리
# 5와 7의 부모 노드인 7의 입장에서는 5 유리
# 2와 6의 부모 노드인 4의 입장에서는 6 유리
# 6과 5의 부모 노드인 4의 입장에서는 6 유리

# depth : 2일때
# (2+5)와 (5+7)의 부모인 8은 (5+7) 유리
# (5+7)와 (6+4)의 부모인 1은 (5+7) 유리
# (6+4)와 (6+4)의 부모인 0은 (6+4) 유리

# depth : 1일때
# (5+7+8)과 (5+7+1)의 부모인 3은 (5+7+8) 유리
# (5+7+1)과 (6+4+0)의 부모인 8은 (5+7+1) 유리

# depth : 0일때
# (5+7+8+3) 과 (5+7+1+8)의 부모인 7은 (5+7+8+3)이 유리

# 정답은 (5+7+8+3)+7 = 30


#0 -> 0+1 (현재 인덱스 +1 까지)
#1 -> 1+2 
#2 -> 2+3
#3 -> 3+4

def pickBiggerSubT(depth, buff) :
    newBuff =[]  
    for i in range(len(depth)) : 
           newBuff.append(max(depth[i] + buff[i], depth[i] + buff[i+1]))
    return newBuff

def solution(triangle):
    buff = triangle.pop()
    
    for depth in triangle[-1::-1]  :
        buff = pickBiggerSubT(depth, buff)
    return buff[0]